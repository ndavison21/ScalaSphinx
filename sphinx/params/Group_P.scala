package sphinx.params

import scala.util.Random
import java.math.BigInteger
import sphinx.exceptions.PowerTooLargeException

/**
 * Group operations mod p
 */
class Group_P extends Group {
  
  // A 2048-bit prime
	private val p = BigInt.apply("19134104382515471340121383082934308828788465164876922483018046665189568608385336521385528455852870226729419515782445769946311524543401780679763787388729547181989737060289407062479214017446428251157469940819568673215805731815521523529008837868909929585628774673216239536406270201585439559139691697966359990510412034461369768357756615060575177060679433618196595458284826534928911045879135540240765445688036648761768417624100416438042808407759355983611319236017991473072964105392335897160201662655194201702312372678481213560443558381777521284259428911914008097936688649209670009892790669991823472515537714171774700422727")

	// A 256-bit prime.  q | p-1, and (p-1)/(2q) is also prime
	private val q = BigInt.apply("106732665057690615308701680462846682779480968671143352109289849544853387479559").toByteArray
	
	// A generator of the 256-bit subgroup of order q
	val g = BigInt.apply("4841394417863494412227539373591815072221868474834407003108964621656948087607533132014406209384264001860614005413470474998618595063750798301826341774223008476018405743602814857378470614748174056572493655989586557587396511347276474665778845699406935799833636365083206218330593315513720711460353255243954204178057633122609221947354829869069875474221603457407347332029203573680170785191212685833773827500371044142146648183369300927714600114538209692069873794191715382617278768149594654315895296485533292574866819385073141870483659577707892565451842181763727355979252885729688362656338077037492411991956527093735651034592").toByteArray
	
	def genSecret: Array[Byte] = {
	  val random = new Array[Byte](256)
	  Random.nextBytes(random)
	  (BigInt.apply(1, random) % BigInt.apply(q)).toByteArray
	}
	
	def expon(base: Array[Byte], power: Array[Byte]): Array[Byte] = BigInt.apply(base).modPow(BigInt.apply(power), p).toByteArray
	
	def multiExpon(base: Array[Byte], powers: List[Array[Byte]]): Array[Byte] = {
	  def product(pwrs: List[Array[Byte]], acc: BigInt): Array[Byte] = {
	    pwrs match {
	      case Nil => acc.toByteArray
	      case x :: tail => product(tail, (acc * BigInt.apply(x)) % BigInt.apply(q))
	    }
	  }
	  expon(base, product(powers, 1)) // TODO: verify is correct for prime-order cyclic group
	}
	
	def makeExp(data: Array[Byte]): Array[Byte] = (BigInt.apply(1, data) % BigInt.apply(q)).toByteArray
	
	def inGroup(a: Array[Byte]): Boolean = {
	  val alpha = BigInt.apply(a)
	  (alpha > 1) && alpha < (p - 1) && (BigInt.apply(expon(a, q)) == 1)
	}
	
	override def printable(alpha: Array[Byte]): String = { Params.byteArrayToStringOfHex(alpha) }
}